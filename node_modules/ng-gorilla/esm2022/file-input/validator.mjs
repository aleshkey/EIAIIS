import { Directive, Input, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import * as i0 from "@angular/core";
export class FileValidator {
    static maxContentSize(bytes) {
        return maxContentSizeValidator(bytes);
    }
}
const MAX_CONTENT_SIZE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MaxContentSizeValidator),
    multi: true
};
export class MaxContentSizeValidator {
    constructor() {
        this._validator = nullValidator;
        this.inputName = 'maxContentSize';
        this.normalizeInput = (input) => toInteger(input);
        this.createValidator = (maxContentSize) => maxContentSizeValidator(maxContentSize);
    }
    ngOnChanges(changes) {
        if (this.inputName in changes) {
            const input = this.normalizeInput(changes[this.inputName].currentValue);
            this._enabled = this.enabled(input);
            this._validator = this._enabled ? this.createValidator(input) : nullValidator;
            if (this._onChange) {
                this._onChange();
            }
        }
    }
    validate(control) {
        return this._validator(control);
    }
    registerOnValidatorChange(fn) {
        this._onChange = fn;
    }
    /**
     * @description
     * Determines whether this validator should be active or not based on an input.
     * Base class implementation checks whether an input is defined (if the value is different from
     * `null` and `undefined`). Validator classes that extend this base class can override this
     * function with the logic specific to a particular validator directive.
     */
    enabled(input) {
        return input != null /* both `null` and `undefined` */;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: MaxContentSizeValidator, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.0.8", type: MaxContentSizeValidator, isStandalone: true, selector: "[maxContentSize][formControlName],[maxContentSize][formControl],[maxContentSize][ngModel]", inputs: { maxContentSize: "maxContentSize" }, host: { properties: { "attr.maxContentSize": "_enabled ? maxContentSize : null" } }, providers: [MAX_CONTENT_SIZE_VALIDATOR], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: MaxContentSizeValidator, decorators: [{
            type: Directive,
            args: [{
                    selector: '[maxContentSize][formControlName],[maxContentSize][formControl],[maxContentSize][ngModel]',
                    providers: [MAX_CONTENT_SIZE_VALIDATOR],
                    host: { '[attr.maxContentSize]': '_enabled ? maxContentSize : null' },
                    standalone: true
                }]
        }], propDecorators: { maxContentSize: [{
                type: Input
            }] } });
/**
 * Method that updates string to integer if not already a number
 *
 * @param value The value to convert to integer.
 * @returns value of parameter converted to number or integer.
 */
function toInteger(value) {
    return typeof value === 'number' ? value : parseInt(value, 10);
}
/**
* Validator that requires the content size of the control's value to be greater than
* to the provided maximum content size. See `FileValidator.maxContentSize` for additional information.
*/
function maxContentSizeValidator(bytes) {
    return (control) => {
        const size = control && control.value ? control.value.map(f => f.file.size).reduce((acc, i) => acc + i, 0) : 0;
        const condition = bytes > size;
        return condition ? null : { maxContentSize: { actualSize: size, maxSize: bytes } };
    };
}
/**
 * Function that has `ValidatorFn` shape, but performs no operation.
 */
function nullValidator(control) {
    return null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ29yaWxsYS9maWxlLWlucHV0L3ZhbGlkYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBNEIsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZGLE9BQU8sRUFBbUIsYUFBYSxFQUE0QyxNQUFNLGdCQUFnQixDQUFDOztBQUcxRyxNQUFNLE9BQU8sYUFBYTtJQUN0QixNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWE7UUFDL0IsT0FBTyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDO0NBQ0o7QUFFRCxNQUFNLDBCQUEwQixHQUFRO0lBQ3BDLE9BQU8sRUFBRSxhQUFhO0lBQ3RCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQXVCLENBQUM7SUFDdEQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBUUYsTUFBTSxPQUFPLHVCQUF1QjtJQU5wQztRQVFZLGVBQVUsR0FBZ0IsYUFBYSxDQUFDO1FBZ0RoRCxjQUFTLEdBQUcsZ0JBQWdCLENBQUM7UUFFN0IsbUJBQWMsR0FBRyxDQUFDLEtBQXNCLEVBQVUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV0RSxvQkFBZSxHQUFHLENBQUMsY0FBc0IsRUFBZSxFQUFFLENBQUMsdUJBQXVCLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDdEc7SUF6Q0csV0FBVyxDQUFDLE9BQXNCO1FBQzlCLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxPQUFPLEVBQUU7WUFDM0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3hFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztZQUM5RSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQzthQUNwQjtTQUNKO0lBQ0wsQ0FBQztJQUVELFFBQVEsQ0FBQyxPQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELHlCQUF5QixDQUFDLEVBQWM7UUFDcEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE9BQU8sQ0FBQyxLQUFjO1FBQ2xCLE9BQU8sS0FBSyxJQUFJLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQztJQUMzRCxDQUFDOzhHQTFDUSx1QkFBdUI7a0dBQXZCLHVCQUF1QiwyUUFKckIsQ0FBQywwQkFBMEIsQ0FBQzs7MkZBSTlCLHVCQUF1QjtrQkFObkMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsMkZBQTJGO29CQUNyRyxTQUFTLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQztvQkFDdkMsSUFBSSxFQUFFLEVBQUUsdUJBQXVCLEVBQUUsa0NBQWtDLEVBQUU7b0JBQ3JFLFVBQVUsRUFBRSxJQUFJO2lCQUNuQjs4QkFpRFksY0FBYztzQkFBdEIsS0FBSzs7QUFTVjs7Ozs7R0FLRztBQUNILFNBQVMsU0FBUyxDQUFDLEtBQXNCO0lBQ3JDLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbkUsQ0FBQztBQUVEOzs7RUFHRTtBQUNGLFNBQVMsdUJBQXVCLENBQUMsS0FBYTtJQUMxQyxPQUFPLENBQUMsT0FBd0IsRUFBa0MsRUFBRTtRQUNoRSxNQUFNLElBQUksR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUUsT0FBTyxDQUFDLEtBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEksTUFBTSxTQUFTLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQztRQUMvQixPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7SUFDdkYsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxhQUFhLENBQUMsT0FBd0I7SUFDM0MsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciwgVmFsaWRhdG9yRm4gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IEZpbGVJbnB1dCB9IGZyb20gJy4vZmlsZS1pbnB1dCc7XHJcblxyXG5leHBvcnQgY2xhc3MgRmlsZVZhbGlkYXRvciB7XHJcbiAgICBzdGF0aWMgbWF4Q29udGVudFNpemUoYnl0ZXM6IG51bWJlcik6IFZhbGlkYXRvckZuIHtcclxuICAgICAgICByZXR1cm4gbWF4Q29udGVudFNpemVWYWxpZGF0b3IoYnl0ZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBNQVhfQ09OVEVOVF9TSVpFX1ZBTElEQVRPUjogYW55ID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heENvbnRlbnRTaXplVmFsaWRhdG9yKSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn07XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW21heENvbnRlbnRTaXplXVtmb3JtQ29udHJvbE5hbWVdLFttYXhDb250ZW50U2l6ZV1bZm9ybUNvbnRyb2xdLFttYXhDb250ZW50U2l6ZV1bbmdNb2RlbF0nLFxyXG4gICAgcHJvdmlkZXJzOiBbTUFYX0NPTlRFTlRfU0laRV9WQUxJREFUT1JdLFxyXG4gICAgaG9zdDogeyAnW2F0dHIubWF4Q29udGVudFNpemVdJzogJ19lbmFibGVkID8gbWF4Q29udGVudFNpemUgOiBudWxsJyB9LFxyXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWF4Q29udGVudFNpemVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IG51bGxWYWxpZGF0b3I7XHJcbiAgICBwcml2YXRlIF9vbkNoYW5nZSE6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsYWcgdGhhdCB0cmFja3Mgd2hldGhlciB0aGlzIHZhbGlkYXRvciBpcyBlbmFibGVkLlxyXG4gICAgICpcclxuICAgICAqIE1hcmtpbmcgaXQgYGludGVybmFsYCAodnMgYHByb3RlY3RlZGApLCBzbyB0aGF0IHRoaXMgZmxhZyBjYW4gYmUgdXNlZCBpbiBob3N0IGJpbmRpbmdzIG9mXHJcbiAgICAgKiBkaXJlY3RpdmUgY2xhc3NlcyB0aGF0IGV4dGVuZCB0aGlzIGJhc2UgY2xhc3MuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2VuYWJsZWQ/OiBib29sZWFuO1xyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5pbnB1dE5hbWUgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMubm9ybWFsaXplSW5wdXQoY2hhbmdlc1t0aGlzLmlucHV0TmFtZV0uY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRoaXMuZW5hYmxlZChpbnB1dCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IHRoaXMuX2VuYWJsZWQgPyB0aGlzLmNyZWF0ZVZhbGlkYXRvcihpbnB1dCkgOiBudWxsVmFsaWRhdG9yO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IoY29udHJvbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHZhbGlkYXRvciBzaG91bGQgYmUgYWN0aXZlIG9yIG5vdCBiYXNlZCBvbiBhbiBpbnB1dC5cclxuICAgICAqIEJhc2UgY2xhc3MgaW1wbGVtZW50YXRpb24gY2hlY2tzIHdoZXRoZXIgYW4gaW5wdXQgaXMgZGVmaW5lZCAoaWYgdGhlIHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tXHJcbiAgICAgKiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgKS4gVmFsaWRhdG9yIGNsYXNzZXMgdGhhdCBleHRlbmQgdGhpcyBiYXNlIGNsYXNzIGNhbiBvdmVycmlkZSB0aGlzXHJcbiAgICAgKiBmdW5jdGlvbiB3aXRoIHRoZSBsb2dpYyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgdmFsaWRhdG9yIGRpcmVjdGl2ZS5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlZChpbnB1dDogdW5rbm93bik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsIC8qIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYCAqLztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogVHJhY2tzIGNoYW5nZXMgdG8gdGhlIG1heGltdW0gY29udGVudCBzaXplIGJvdW5kIHRvIHRoaXMgZGlyZWN0aXZlLlxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBtYXhDb250ZW50U2l6ZSE6IHN0cmluZyB8IG51bWJlciB8IG51bGw7XHJcblxyXG4gICAgaW5wdXROYW1lID0gJ21heENvbnRlbnRTaXplJztcclxuXHJcbiAgICBub3JtYWxpemVJbnB1dCA9IChpbnB1dDogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyID0+IHRvSW50ZWdlcihpbnB1dCk7XHJcblxyXG4gICAgY3JlYXRlVmFsaWRhdG9yID0gKG1heENvbnRlbnRTaXplOiBudW1iZXIpOiBWYWxpZGF0b3JGbiA9PiBtYXhDb250ZW50U2l6ZVZhbGlkYXRvcihtYXhDb250ZW50U2l6ZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXRob2QgdGhhdCB1cGRhdGVzIHN0cmluZyB0byBpbnRlZ2VyIGlmIG5vdCBhbHJlYWR5IGEgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB2YWx1ZSBvZiBwYXJhbWV0ZXIgY29udmVydGVkIHRvIG51bWJlciBvciBpbnRlZ2VyLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250ZW50IHNpemUgb2YgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW5cclxuKiB0byB0aGUgcHJvdmlkZWQgbWF4aW11bSBjb250ZW50IHNpemUuIFNlZSBgRmlsZVZhbGlkYXRvci5tYXhDb250ZW50U2l6ZWAgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXHJcbiovXHJcbmZ1bmN0aW9uIG1heENvbnRlbnRTaXplVmFsaWRhdG9yKGJ5dGVzOiBudW1iZXIpOiBWYWxpZGF0b3JGbiB7XHJcbiAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHsgW2tleTogc3RyaW5nXTogYW55OyB9IHwgbnVsbCA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNvbnRyb2wgJiYgY29udHJvbC52YWx1ZSA/IChjb250cm9sLnZhbHVlIGFzIEZpbGVJbnB1dFtdKS5tYXAoZiA9PiBmLmZpbGUuc2l6ZSkucmVkdWNlKChhY2MsIGkpID0+IGFjYyArIGksIDApIDogMDtcclxuICAgICAgICBjb25zdCBjb25kaXRpb24gPSBieXRlcyA+IHNpemU7XHJcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG51bGwgOiB7IG1heENvbnRlbnRTaXplOiB7IGFjdHVhbFNpemU6IHNpemUsIG1heFNpemU6IGJ5dGVzIH0gfTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0aGF0IGhhcyBgVmFsaWRhdG9yRm5gIHNoYXBlLCBidXQgcGVyZm9ybXMgbm8gb3BlcmF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbnVsbFZhbGlkYXRvcihjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxufSJdfQ==